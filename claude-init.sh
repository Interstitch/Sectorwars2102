#!/bin/bash

# CLAUDE.md Self-Improving Development System Initializer
# This script bootstraps the autonomous development methodology in any project

set -e

echo "🧬 Initializing CLAUDE.md Self-Improving Development System..."

# Detect project type and structure
detect_project_type() {
    if [ -f "package.json" ]; then
        echo "node"
    elif [ -f "requirements.txt" ] || [ -f "setup.py" ]; then
        echo "python"
    elif [ -f "Cargo.toml" ]; then
        echo "rust"
    elif [ -f "go.mod" ]; then
        echo "go"
    else
        echo "generic"
    fi
}

# Detect if this is already a CLAUDE-managed project
detect_claude_project() {
    local score=0
    
    # Check for CLAUDE.md
    if [ -f "CLAUDE.md" ]; then
        ((score+=3))
    fi
    
    # Check for .claude directory
    if [ -d ".claude" ]; then
        ((score+=2))
    fi
    
    # Check for docs structure
    if [ -d "docs/ideas" ] || [ -d "docs/patterns" ]; then
        ((score+=1))
    fi
    
    # Consider it a CLAUDE project if score > 3
    if [ $score -ge 3 ]; then
        echo "true"
    else
        echo "false"
    fi
}

# Collect existing patterns if this is a CLAUDE project
collect_existing_patterns() {
    if [ "$(detect_claude_project)" = "true" ]; then
        echo "🔍 Collecting existing CLAUDE patterns..."
        
        # Create patterns directory if it doesn't exist
        mkdir -p .claude/patterns
        
        # Collect patterns from existing files
        if [ -f ".claude/patterns/discovered.json" ]; then
            cp .claude/patterns/discovered.json .claude/patterns/discovered.json.bak
            echo "📊 Backed up existing patterns"
        fi
        
        # Collect from logs if they exist
        if [ -d ".claude/memory" ]; then
            echo "📚 Analyzing memory logs..."
            if [ -f ".claude/memory/commits.log" ]; then
                echo "Found commit history for learning"
            fi
        fi
    fi
}

# Create directory structure
create_directories() {
    echo "📁 Creating directory structure..."
    mkdir -p docs/{ideas,development-plans,api,data-models,user-guides,retrospectives,metrics,patterns}
    mkdir -p .claude/{memory,patterns,metrics}
    mkdir -p tests/{unit,integration,e2e}
}

# Setup or enhance CLAUDE.md
setup_claude_md() {
    if [ ! -f "CLAUDE.md" ]; then
        echo "📄 Creating CLAUDE.md..."
        cat > CLAUDE.md << 'EOF'
# CLAUDE.md - Self-Improving Development System

This file was auto-generated by claude-init.sh and will evolve autonomously.

## System DNA
- **Prime Directive**: Continuously improve both code and process
- **Core Values**: Quality, Learning, Automation, Evolution
- **Success Metric**: Each iteration better than the last

## Current Project Analysis
EOF
        
        # Add project-specific analysis
        echo "### Project Type: $(detect_project_type)" >> CLAUDE.md
        echo "### Initialized: $(date)" >> CLAUDE.md
        echo "" >> CLAUDE.md
        
        # Copy rest of CLAUDE.md content from source
        if [ -f "$CLAUDE_SOURCE/CLAUDE.md" ]; then
            tail -n +20 "$CLAUDE_SOURCE/CLAUDE.md" >> CLAUDE.md
        fi
    else
        echo "🔄 CLAUDE.md already exists, enhancing..."
        # Create temporary backup of existing CLAUDE.md
        cp CLAUDE.md CLAUDE.md.bak
        
        # Check if key sections exist and add them if missing
        if ! grep -q "System DNA" CLAUDE.md; then
            echo "👉 Adding System DNA section..."
            sed -i '1s/^/# CLAUDE.md - Self-Improving Development System\n\n## System DNA\n- **Prime Directive**: Continuously improve both code and process\n- **Core Values**: Quality, Learning, Automation, Evolution\n- **Success Metric**: Each iteration better than the last\n\n/' CLAUDE.md
        fi
        
        # Update project analysis section
        if grep -q "Project Type:" CLAUDE.md; then
            echo "👉 Updating project analysis..."
            sed -i "s/### Project Type:.*/### Project Type: $(detect_project_type)/" CLAUDE.md
        else
            echo "👉 Adding project analysis..."
            echo -e "\n## Current Project Analysis\n### Project Type: $(detect_project_type)\n### Last Updated: $(date)" >> CLAUDE.md
        fi
        
        # Merge any new sections from template if available
        if [ -f "$CLAUDE_SOURCE/CLAUDE.md" ]; then
            echo "👉 Merging template improvements..."
            # Extract sections from template that might not exist in current file
            grep -A 5 "^## " "$CLAUDE_SOURCE/CLAUDE.md" | while read -r section; do
                if [[ "$section" =~ ^## ]] && ! grep -q "$section" CLAUDE.md; then
                    echo -e "\n$section" >> CLAUDE.md
                    # Grab a few lines after section header
                    grep -A 5 "$section" "$CLAUDE_SOURCE/CLAUDE.md" | tail -n +2 >> CLAUDE.md
                fi
            done
        fi
        
        echo "✅ CLAUDE.md enhanced while preserving customizations"
    fi
}

# Initialize metrics tracking
init_metrics() {
    echo "📊 Initializing metrics tracking..."
    
    # Create metrics directory if it doesn't exist
    mkdir -p .claude/metrics
    
    # Check if metrics already exist and create a backup
    if [ -f ".claude/metrics/baseline.json" ]; then
        cp .claude/metrics/baseline.json .claude/metrics/baseline.json.bak
        echo "📊 Backed up existing metrics baseline"
        
        # Add update timestamp to existing metrics
        cat > .claude/metrics/baseline_update.json << EOF
{
  "updated": "$(date -u +"%Y-%m-%dT%H:%M:%SZ")",
  "files_now": $(find . -type f -name "*.$(detect_project_type == 'node' && echo 'js' || echo 'py')" 2>/dev/null | wc -l || echo 0),
  "test_files_now": $(find tests -type f 2>/dev/null | wc -l || echo 0),
  "todo_count_now": $(grep -r "TODO" . --include="*.js" --include="*.py" --include="*.ts" --include="*.go" --include="*.rs" 2>/dev/null | wc -l || echo 0),
  "complexity_metrics": {
    "avg_file_size_bytes": $(find . -type f -name "*.$(detect_project_type == 'node' && echo 'js' || echo 'py')" -not -path "*/node_modules/*" -not -path "*/.git/*" 2>/dev/null | xargs cat 2>/dev/null | wc -c 2>/dev/null || echo 0),
    "total_files": $(find . -type f -not -path "*/node_modules/*" -not -path "*/.git/*" 2>/dev/null | wc -l || echo 0)
  }
}
EOF
    else
        # Create new baseline metrics
        cat > .claude/metrics/baseline.json << EOF
{
  "initialized": "$(date -u +"%Y-%m-%dT%H:%M:%SZ")",
  "project_type": "$(detect_project_type)",
  "initial_metrics": {
    "files": $(find . -type f -name "*.$(detect_project_type == 'node' && echo 'js' || echo 'py')" -not -path "*/node_modules/*" -not -path "*/.git/*" 2>/dev/null | wc -l || echo 0),
    "test_files": $(find tests -type f 2>/dev/null | wc -l || echo 0),
    "todo_count": $(grep -r "TODO" . --include="*.js" --include="*.py" --include="*.ts" --include="*.go" --include="*.rs" 2>/dev/null | wc -l || echo 0),
    "directories": $(find . -type d -not -path "*/node_modules/*" -not -path "*/.git/*" 2>/dev/null | wc -l || echo 0)
  }
}
EOF
    fi
    
    # Create events file if it doesn't exist
    if [ ! -f ".claude/metrics/events.jsonl" ]; then
        touch .claude/metrics/events.jsonl
        echo "{\"event\": \"init\", \"timestamp\": \"$(date -u +"%Y-%m-%dT%H:%M:%SZ")\"}" >> .claude/metrics/events.jsonl
    fi
}

# Setup git hooks for continuous improvement
setup_git_hooks() {
    echo "🪝 Setting up git hooks..."
    mkdir -p .git/hooks
    
    # Pre-commit hook for quality checks
    cat > .git/hooks/pre-commit << 'EOF'
#!/bin/bash
# Auto-generated by CLAUDE.md system

echo "🔍 Running CLAUDE.md pre-commit checks..."

# Update metrics
if [ -f ".claude/metrics/track.sh" ]; then
    .claude/metrics/track.sh pre-commit
fi

# Check for TODOs
new_todos=$(git diff --cached | grep -c "^+.*TODO" || true)
if [ $new_todos -gt 0 ]; then
    echo "📝 Added $new_todos new TODOs"
fi

exit 0
EOF
    chmod +x .git/hooks/pre-commit
    
    # Post-commit hook for learning
    cat > .git/hooks/post-commit << 'EOF'
#!/bin/bash
# Auto-generated by CLAUDE.md system

echo "📚 CLAUDE.md learning from commit..."

# Extract patterns
commit_msg=$(git log -1 --pretty=%B)
echo "$(date): $commit_msg" >> .claude/memory/commits.log

# Update pattern recognition
if [ -f ".claude/patterns/learn.sh" ]; then
    .claude/patterns/learn.sh "$commit_msg"
fi
EOF
    chmod +x .git/hooks/post-commit
}

# Create learning scripts
create_learning_scripts() {
    echo "🧠 Creating learning scripts..."
    
    # Pattern learning script
    cat > .claude/patterns/learn.sh << 'EOF'
#!/bin/bash
# Pattern learning system

PATTERN_FILE=".claude/patterns/discovered.json"
COMMIT_MSG="$1"

mkdir -p .claude/patterns

# Initialize patterns file if it doesn't exist
if [ ! -f "$PATTERN_FILE" ]; then
    echo '{
  "bug_fixes": [],
  "features": [],
  "refactors": [],
  "docs": [],
  "tests": [],
  "performance": [],
  "other": []
}' > "$PATTERN_FILE"
fi

# Extract patterns from commit message
if [[ "$COMMIT_MSG" =~ fix|bug|hotfix|issue ]]; then
    echo "$(date): Bug fix pattern detected" >> .claude/patterns/bug_patterns.log
    
    # Extract issue numbers if present
    if [[ "$COMMIT_MSG" =~ '#'[0-9]+ ]]; then
        ISSUE_NUM=$(echo "$COMMIT_MSG" | grep -o '#[0-9]\+' | head -1)
        echo "  - Related to issue $ISSUE_NUM" >> .claude/patterns/bug_patterns.log
    fi
    
    # Update the JSON with the new pattern
    TMP=$(mktemp)
    jq --arg msg "$COMMIT_MSG" '.bug_fixes += [$msg]' "$PATTERN_FILE" > "$TMP" && mv "$TMP" "$PATTERN_FILE"
fi

if [[ "$COMMIT_MSG" =~ feat|feature|add|new ]]; then
    echo "$(date): Feature pattern detected" >> .claude/patterns/feature_patterns.log
    
    # Update the JSON with the new pattern
    TMP=$(mktemp)
    jq --arg msg "$COMMIT_MSG" '.features += [$msg]' "$PATTERN_FILE" > "$TMP" && mv "$TMP" "$PATTERN_FILE"
fi

if [[ "$COMMIT_MSG" =~ refactor|clean|improve ]]; then
    echo "$(date): Refactor pattern detected" >> .claude/patterns/refactor_patterns.log
    
    # Update the JSON with the new pattern
    TMP=$(mktemp)
    jq --arg msg "$COMMIT_MSG" '.refactors += [$msg]' "$PATTERN_FILE" > "$TMP" && mv "$TMP" "$PATTERN_FILE"
fi

if [[ "$COMMIT_MSG" =~ docs|documentation|comment ]]; then
    echo "$(date): Documentation pattern detected" >> .claude/patterns/doc_patterns.log
    
    # Update the JSON with the new pattern
    TMP=$(mktemp)
    jq --arg msg "$COMMIT_MSG" '.docs += [$msg]' "$PATTERN_FILE" > "$TMP" && mv "$TMP" "$PATTERN_FILE"
fi

if [[ "$COMMIT_MSG" =~ test|spec|assert ]]; then
    echo "$(date): Test pattern detected" >> .claude/patterns/test_patterns.log
    
    # Update the JSON with the new pattern
    TMP=$(mktemp)
    jq --arg msg "$COMMIT_MSG" '.tests += [$msg]' "$PATTERN_FILE" > "$TMP" && mv "$TMP" "$PATTERN_FILE"
fi

if [[ "$COMMIT_MSG" =~ perf|performance|optimize|speed ]]; then
    echo "$(date): Performance pattern detected" >> .claude/patterns/perf_patterns.log
    
    # Update the JSON with the new pattern
    TMP=$(mktemp)
    jq --arg msg "$COMMIT_MSG" '.performance += [$msg]' "$PATTERN_FILE" > "$TMP" && mv "$TMP" "$PATTERN_FILE"
fi
EOF
    chmod +x .claude/patterns/learn.sh
    
    # Metrics tracking script
    cat > .claude/metrics/track.sh << 'EOF'
#!/bin/bash
# Metrics tracking system

EVENT="$1"
TIMESTAMP=$(date -u +"%Y-%m-%dT%H:%M:%SZ")

# Track various metrics
case "$EVENT" in
    "pre-commit")
        FILES_CHANGED=$(git diff --cached --name-only | wc -l)
        echo "{\"event\": \"commit\", \"timestamp\": \"$TIMESTAMP\", \"files_changed\": $FILES_CHANGED}" >> .claude/metrics/events.jsonl
        ;;
    "test")
        TEST_COUNT=$(find tests -type f | wc -l)
        echo "{\"event\": \"test\", \"timestamp\": \"$TIMESTAMP\", \"test_count\": $TEST_COUNT}" >> .claude/metrics/events.jsonl
        ;;
esac
EOF
    chmod +x .claude/metrics/track.sh
}

# Setup project-specific tooling
setup_project_tools() {
    PROJECT_TYPE=$(detect_project_type)
    echo "🔧 Setting up $PROJECT_TYPE project tools..."
    
    case "$PROJECT_TYPE" in
        "node")
            # Add npm scripts if package.json exists
            if [ -f "package.json" ] && command -v jq &> /dev/null; then
                echo "Adding CLAUDE.md npm scripts..."
                jq '.scripts += {
                    "claude:analyze": "echo \"Running CLAUDE.md analysis...\" && find . -name \"*.js\" -o -name \"*.ts\" | xargs wc -l",
                    "claude:metrics": "bash .claude/metrics/track.sh test",
                    "claude:learn": "bash .claude/patterns/learn.sh",
                    "claude:report": "echo \"Generating CLAUDE.md report...\" && node .claude/report.js"
                }' package.json > package.json.tmp && mv package.json.tmp package.json
                
                # Create a simple reporting script
                cat > .claude/report.js << 'EOF'
#!/usr/bin/env node
// CLAUDE.md reporting system

console.log("📊 CLAUDE.md Project Report");

// Load the metrics data
const fs = require('fs');
try {
  const baselineData = JSON.parse(fs.readFileSync('.claude/metrics/baseline.json', 'utf8'));
  console.log(`\nInitialized: ${baselineData.initialized}`);
  console.log(`Project Type: ${baselineData.project_type}`);
  
  // Display metrics
  console.log("\n== Initial Metrics ==");
  for (const [key, value] of Object.entries(baselineData.initial_metrics)) {
    console.log(`${key}: ${value}`);
  }
  
  // Load and display patterns if they exist
  try {
    const patternsData = JSON.parse(fs.readFileSync('.claude/patterns/discovered.json', 'utf8'));
    console.log("\n== Discovered Patterns ==");
    for (const [category, items] of Object.entries(patternsData)) {
      if (items.length > 0) {
        console.log(`\n${category}: ${items.length}`);
        items.slice(0, 3).forEach(item => console.log(`- ${item}`));
        if (items.length > 3) console.log(`  (and ${items.length - 3} more...)`);
      }
    }
  } catch (err) {
    console.log("\nNo patterns discovered yet.");
  }
  
} catch (err) {
  console.error("Error loading metrics data:", err);
}
EOF
                chmod +x .claude/report.js
            fi
            ;;
        "python")
            # Create Python-specific analysis tools
            cat > .claude/analyze.py << 'EOF'
#!/usr/bin/env python3
"""CLAUDE.md Python analyzer"""

import ast
import os
import json
from pathlib import Path
from collections import defaultdict

def analyze_complexity():
    """Analyze code complexity"""
    results = defaultdict(list)
    
    for py_file in Path('.').rglob('*.py'):
        if 'node_modules' in str(py_file) or '.git' in str(py_file):
            continue
            
        try:
            with open(py_file, 'r') as f:
                content = f.read()
                tree = ast.parse(content)
                
                # Count functions
                functions = [node for node in ast.walk(tree) if isinstance(node, ast.FunctionDef)]
                
                # Count classes
                classes = [node for node in ast.walk(tree) if isinstance(node, ast.ClassDef)]
                
                # Calculate complexity (simplified)
                complexity = len(functions) * 2 + len(classes) * 3
                
                results["files"].append({
                    "path": str(py_file),
                    "functions": len(functions),
                    "classes": len(classes),
                    "complexity": complexity
                })
                
        except Exception as e:
            print(f"Error analyzing {py_file}: {e}")
    
    # Save results
    os.makedirs('.claude/metrics', exist_ok=True)
    with open('.claude/metrics/code_complexity.json', 'w') as f:
        json.dump(results, f, indent=2)
    
    print(f"Analyzed {len(results['files'])} Python files")
    print(f"Average complexity: {sum(f['complexity'] for f in results['files']) / len(results['files']) if results['files'] else 0:.2f}")

if __name__ == "__main__":
    analyze_complexity()
EOF
            chmod +x .claude/analyze.py
            
            # Create a requirements file for CLAUDE analysis tools
            cat > .claude/requirements.txt << 'EOF'
# CLAUDE.md Python analysis tool requirements
pylint
pytest-cov
black
EOF
            ;;
        "rust")
            # Create Rust-specific analysis tools
            mkdir -p .claude/tools/rust
            cat > .claude/tools/rust/analyze.sh << 'EOF'
#!/bin/bash
# CLAUDE.md Rust analyzer

# Check if cargo exists
if ! command -v cargo &> /dev/null; then
    echo "cargo not found, Rust analysis skipped"
    exit 0
fi

echo "📊 Running Rust analysis..."

# Run clippy if available
if cargo clippy --version &> /dev/null; then
    cargo clippy -- -D warnings
fi

# Check code formatting
if cargo fmt --version &> /dev/null; then
    cargo fmt -- --check
fi

# Run tests to check coverage
cargo test
EOF
            chmod +x .claude/tools/rust/analyze.sh
            ;;
        "go")
            # Create Go-specific analysis tools
            mkdir -p .claude/tools/go
            cat > .claude/tools/go/analyze.sh << 'EOF'
#!/bin/bash
# CLAUDE.md Go analyzer

# Check if go exists
if ! command -v go &> /dev/null; then
    echo "go not found, Go analysis skipped"
    exit 0
fi

echo "📊 Running Go analysis..."

# Run static code analysis
if command -v golint &> /dev/null; then
    golint ./...
else
    echo "golint not found, install with: go install golang.org/x/lint/golint@latest"
fi

# Check code formatting
go fmt ./...

# Run tests to check coverage
go test -cover ./...
EOF
            chmod +x .claude/tools/go/analyze.sh
            ;;
        *)
            echo "Generic project type detected, setting up basic tools..."
            mkdir -p .claude/tools/generic
            cat > .claude/tools/generic/analyze.sh << 'EOF'
#!/bin/bash
# CLAUDE.md generic analyzer

echo "📊 Running generic analysis..."

# Count files by extension
echo "File counts by extension:"
find . -type f -name "*.*" | grep -v "node_modules\|.git" | sed 's/.*\.//' | sort | uniq -c | sort -nr

# Count lines of code (rough estimate)
echo "Lines of code (estimate):"
find . -type f -name "*.*" | grep -v "node_modules\|.git" | xargs wc -l 2>/dev/null | tail -1
EOF
            chmod +x .claude/tools/generic/analyze.sh
            ;;
    esac
}

# Create initial ideas file
create_ideas_file() {
    echo "💡 Creating initial ideas file..."
    cat > docs/ideas.md << EOF
# Ideas Backlog

Generated by CLAUDE.md Self-Improving System on $(date)

## Autonomous Improvements Queue

### High Priority
1. **Automated Code Review**: Implement pre-commit hooks that analyze code quality
   - Priority Score: 20 (Impact: 5, Feasibility: 4, Effort: 1)
   - Auto-detected based on lack of code review tooling

2. **Test Coverage Tracking**: Set up automated test coverage reporting
   - Priority Score: 16 (Impact: 4, Feasibility: 4, Effort: 1)
   - Auto-detected based on missing coverage configuration

### Medium Priority
3. **Documentation Generation**: Auto-generate API docs from code comments
   - Priority Score: 12 (Impact: 3, Feasibility: 4, Effort: 1)

### Discovered Patterns
_This section will be populated automatically as the system learns_

## Improvement Ideas
_Add your own ideas here. The system will learn from them._
EOF
}

# Self-improve the claude-init.sh script
self_improve() {
    echo "🧠 Checking for self-improvement opportunities..."
    
    # Create a backup of the current script
    SCRIPT_PATH="$0"
    BACKUP_PATH="${SCRIPT_PATH}.bak"
    cp "$SCRIPT_PATH" "$BACKUP_PATH"
    echo "📑 Created backup at $BACKUP_PATH"
    
    # Look for common issues in the script
    echo "🔍 Analyzing script for improvements..."
    
    # Check for missing command checks
    if ! grep -q "command -v jq" "$SCRIPT_PATH"; then
        echo "⚠️  No check for jq dependency - consider adding"
    fi
    
    # Check for error handling
    if ! grep -q "set -e" "$SCRIPT_PATH"; then
        echo "⚠️  No 'set -e' found - consider adding for better error handling"
        # Add 'set -e' to the beginning of the script
        sed -i '3i set -e' "$SCRIPT_PATH"
        echo "✅ Added 'set -e' for error handling"
    fi
    
    # Check if we're running the latest version
    if [ -f ".claude/.self_version" ]; then
        CURRENT_VERSION=$(cat .claude/.self_version)
        SCRIPT_VERSION="1.1.0" # Hardcoded current version
        
        if [ "$CURRENT_VERSION" != "$SCRIPT_VERSION" ]; then
            echo "📈 Upgrading from version $CURRENT_VERSION to $SCRIPT_VERSION"
            echo "$SCRIPT_VERSION" > .claude/.self_version
        fi
    else
        mkdir -p .claude
        echo "1.1.0" > .claude/.self_version
        echo "📝 Initialized version tracking"
    fi
    
    echo "✨ Self-improvement check complete"
}

# Main initialization
main() {
    CLAUDE_SOURCE="${CLAUDE_SOURCE:-$(dirname "$0")}"
    
    echo "🚀 Starting CLAUDE.md initialization..."
    echo "   Project type: $(detect_project_type)"
    echo "   Working directory: $(pwd)"
    echo ""
    
    # Check if this is already a CLAUDE project
    IS_CLAUDE_PROJECT=$(detect_claude_project)
    if [ "$IS_CLAUDE_PROJECT" = "true" ]; then
        echo "🔎 Detected existing CLAUDE.md project structure"
        collect_existing_patterns
    fi
    
    # Self-improve the script if running in a CLAUDE project
    if [ "$IS_CLAUDE_PROJECT" = "true" ]; then
        self_improve
    fi
    
    create_directories
    setup_claude_md
    init_metrics
    setup_git_hooks
    create_learning_scripts
    setup_project_tools
    
    # Only create ideas file if it doesn't exist
    if [ ! -f "docs/ideas.md" ] && [ ! -f "docs/ideas/README.md" ]; then
        create_ideas_file
    else
        echo "📝 Ideas file already exists, preserving..."
    fi
    
    # Create marker file
    touch .claude/.initialized
    
    if [ "$IS_CLAUDE_PROJECT" = "true" ]; then
        echo ""
        echo "✅ CLAUDE.md Self-Improving Development System upgraded!"
        echo ""
        echo "📚 Next steps:"
        echo "   1. Review the enhanced CLAUDE.md for new features"
        echo "   2. Check .claude directory for new tooling"
        echo "   3. Continue your development with improved support"
    else
        echo ""
        echo "✅ CLAUDE.md Self-Improving Development System initialized!"
        echo ""
        echo "📚 Next steps:"
        echo "   1. Review and customize CLAUDE.md for your project"
        echo "   2. Run your first development iteration"
        echo "   3. Watch the system learn and improve"
    fi
    
    echo ""
    echo "🧬 The system will now evolve with your project."
}

# Run main function
main "$@"