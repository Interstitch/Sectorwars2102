"""
Scratchpad Manager for agent-to-agent communication
"""
import os
import json
import logging
import aiofiles
from datetime import datetime
from typing import Dict, Optional, Any, List
from .models import AgentMessage


class ScratchpadManager:
    """
    Manages file-based communication between agents via scratchpads
    """
    
    def __init__(self, workspace_path: str):
        self.scratchpad_dir = f"{workspace_path}/scratchpads"
        self.logger = logging.getLogger(__name__)
        
        # Ensure scratchpads directory exists
        os.makedirs(self.scratchpad_dir, exist_ok=True)
        
        # Initialize communication channels
        self.channels = {
            "aria_to_code": f"{self.scratchpad_dir}/aria_to_code.md",
            "code_to_alpha": f"{self.scratchpad_dir}/code_to_alpha.md",
            "alpha_to_beta": f"{self.scratchpad_dir}/alpha_to_beta.md",
            "beta_to_aria": f"{self.scratchpad_dir}/beta_to_aria.md",
            "shared_context": f"{self.scratchpad_dir}/shared_context.md",
            "orchestrator_feedback": f"{self.scratchpad_dir}/orchestrator_feedback.md"
        }
    
    async def write_message(self, from_agent: str, to_agent: str, content: Dict[str, Any]):
        """
        Write a message from one agent to another via scratchpad
        """
        try:
            channel_key = f"{from_agent}_to_{to_agent}"
            filepath = self.channels.get(channel_key)
            
            if not filepath:
                # Create dynamic channel if it doesn't exist
                filepath = f"{self.scratchpad_dir}/{from_agent}_to_{to_agent}.md"
                self.channels[channel_key] = filepath
            
            timestamp = datetime.utcnow().isoformat()
            
            message_data = {
                "timestamp": timestamp,
                "from": from_agent,
                "to": to_agent,
                "content": content
            }
            
            # Create markdown format for better readability
            markdown_content = f"""# Message from {from_agent} to {to_agent}

**Timestamp**: {timestamp}
**From**: {from_agent}
**To**: {to_agent}

## Content

```json
{json.dumps(content, indent=2)}
```

## Raw Data

```json
{json.dumps(message_data, indent=2)}
```

---
*Generated by NEXUS Multi-Agent Orchestrator*
"""
            
            async with aiofiles.open(filepath, 'w') as f:
                await f.write(markdown_content)
            
            self.logger.info(f"Wrote message from {from_agent} to {to_agent}")
            
        except Exception as e:
            self.logger.error(f"Failed to write message from {from_agent} to {to_agent}: {e}")
            raise
    
    async def read_latest_message(self, from_agent: str, to_agent: str) -> Optional[Dict[str, Any]]:
        """
        Read the latest message from one agent to another
        """
        try:
            channel_key = f"{from_agent}_to_{to_agent}"
            filepath = self.channels.get(channel_key)
            
            if not filepath or not os.path.exists(filepath):
                return None
            
            async with aiofiles.open(filepath, 'r') as f:
                content = await f.read()
            
            # Parse the markdown to extract JSON data
            parsed_data = self._parse_scratchpad_content(content)
            
            self.logger.debug(f"Read message from {from_agent} to {to_agent}")
            return parsed_data
            
        except Exception as e:
            self.logger.error(f"Failed to read message from {from_agent} to {to_agent}: {e}")
            return None
    
    async def write_shared_context(self, context: Dict[str, Any]):
        """
        Write shared context information accessible to all agents
        """
        try:
            filepath = self.channels["shared_context"]
            timestamp = datetime.utcnow().isoformat()
            
            markdown_content = f"""# Shared Context

**Last Updated**: {timestamp}

## Project Context

```json
{json.dumps(context, indent=2)}
```

---
*Generated by NEXUS Multi-Agent Orchestrator*
"""
            
            async with aiofiles.open(filepath, 'w') as f:
                await f.write(markdown_content)
            
            self.logger.info("Updated shared context")
            
        except Exception as e:
            self.logger.error(f"Failed to write shared context: {e}")
            raise
    
    async def read_shared_context(self) -> Optional[Dict[str, Any]]:
        """
        Read shared context information
        """
        try:
            filepath = self.channels["shared_context"]
            
            if not os.path.exists(filepath):
                return None
            
            async with aiofiles.open(filepath, 'r') as f:
                content = await f.read()
            
            return self._parse_scratchpad_content(content)
            
        except Exception as e:
            self.logger.error(f"Failed to read shared context: {e}")
            return None
    
    async def write_orchestrator_feedback(self, feedback: Dict[str, Any]):
        """
        Write feedback from the orchestrator to all agents
        """
        try:
            filepath = self.channels["orchestrator_feedback"]
            timestamp = datetime.utcnow().isoformat()
            
            markdown_content = f"""# Orchestrator Feedback

**Timestamp**: {timestamp}
**From**: NEXUS Prime Orchestrator

## Feedback

```json
{json.dumps(feedback, indent=2)}
```

---
*Generated by NEXUS Multi-Agent Orchestrator*
"""
            
            async with aiofiles.open(filepath, 'w') as f:
                await f.write(markdown_content)
            
            self.logger.info("Updated orchestrator feedback")
            
        except Exception as e:
            self.logger.error(f"Failed to write orchestrator feedback: {e}")
            raise
    
    async def read_orchestrator_feedback(self) -> Optional[Dict[str, Any]]:
        """
        Read latest orchestrator feedback
        """
        try:
            filepath = self.channels["orchestrator_feedback"]
            
            if not os.path.exists(filepath):
                return None
            
            async with aiofiles.open(filepath, 'r') as f:
                content = await f.read()
            
            return self._parse_scratchpad_content(content)
            
        except Exception as e:
            self.logger.error(f"Failed to read orchestrator feedback: {e}")
            return None
    
    async def clear_channel(self, from_agent: str, to_agent: str):
        """
        Clear a communication channel
        """
        try:
            channel_key = f"{from_agent}_to_{to_agent}"
            filepath = self.channels.get(channel_key)
            
            if filepath and os.path.exists(filepath):
                os.remove(filepath)
                self.logger.info(f"Cleared channel from {from_agent} to {to_agent}")
            
        except Exception as e:
            self.logger.error(f"Failed to clear channel from {from_agent} to {to_agent}: {e}")
    
    async def clear_all_channels(self):
        """
        Clear all communication channels
        """
        try:
            for channel_path in self.channels.values():
                if os.path.exists(channel_path):
                    os.remove(channel_path)
            
            self.logger.info("Cleared all communication channels")
            
        except Exception as e:
            self.logger.error(f"Failed to clear all channels: {e}")
    
    def get_active_channels(self) -> List[str]:
        """
        Get list of active communication channels
        """
        active_channels = []
        
        for channel_name, filepath in self.channels.items():
            if os.path.exists(filepath):
                active_channels.append(channel_name)
        
        return active_channels
    
    async def get_channel_status(self) -> Dict[str, Dict[str, Any]]:
        """
        Get status of all communication channels
        """
        status = {}
        
        for channel_name, filepath in self.channels.items():
            if os.path.exists(filepath):
                try:
                    stat = os.stat(filepath)
                    status[channel_name] = {
                        "exists": True,
                        "size": stat.st_size,
                        "modified": datetime.fromtimestamp(stat.st_mtime).isoformat(),
                        "path": filepath
                    }
                except Exception as e:
                    status[channel_name] = {
                        "exists": True,
                        "error": str(e),
                        "path": filepath
                    }
            else:
                status[channel_name] = {
                    "exists": False,
                    "path": filepath
                }
        
        return status
    
    def _parse_scratchpad_content(self, content: str) -> Optional[Dict[str, Any]]:
        """
        Parse scratchpad markdown content to extract JSON data
        """
        try:
            # Look for JSON blocks in the markdown
            lines = content.split('\n')
            json_lines = []
            in_json_block = False
            
            for line in lines:
                if line.strip() == '```json' and not in_json_block:
                    in_json_block = True
                    continue
                elif line.strip() == '```' and in_json_block:
                    break
                elif in_json_block:
                    json_lines.append(line)
            
            if json_lines:
                json_text = '\n'.join(json_lines)
                return json.loads(json_text)
            
            return None
            
        except Exception as e:
            self.logger.warning(f"Failed to parse scratchpad content: {e}")
            return None
    
    async def create_communication_summary(self) -> Dict[str, Any]:
        """
        Create a summary of all communication channels
        """
        summary = {
            "timestamp": datetime.utcnow().isoformat(),
            "channels": {},
            "active_count": 0,
            "total_channels": len(self.channels)
        }
        
        for channel_name, filepath in self.channels.items():
            if os.path.exists(filepath):
                try:
                    async with aiofiles.open(filepath, 'r') as f:
                        content = await f.read()
                    
                    parsed_data = self._parse_scratchpad_content(content)
                    
                    summary["channels"][channel_name] = {
                        "active": True,
                        "has_content": parsed_data is not None,
                        "last_message": parsed_data.get("timestamp") if parsed_data else None
                    }
                    summary["active_count"] += 1
                    
                except Exception as e:
                    summary["channels"][channel_name] = {
                        "active": True,
                        "error": str(e)
                    }
            else:
                summary["channels"][channel_name] = {
                    "active": False
                }
        
        return summary