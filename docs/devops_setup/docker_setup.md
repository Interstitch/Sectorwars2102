# Sector Wars 2102 - Docker Setup (Iteration 1)\n\n**Document Owner:** DevOps (Simulated)\n**Date:** May 10, 2025\n\nThis document outlines the planned Docker setup for the Sector Wars 2102 project. The goal is to create a consistent and reproducible development and deployment environment.\n\n## Components:\n\nThe Docker environment will consist of the following services, orchestrated by `docker-compose.yml`:\n\n1.  **PHP Application Service (`app`):**\n    *   **Base Image:** A suitable official PHP image (e.g., `php:8.2-fpm` or `php:8.3-fpm`). The FPM (FastCGI Process Manager) variant is chosen for better integration with a web server like Nginx.\n    *   **PHP Extensions:** Will include necessary extensions for a web application and PostgreSQL connectivity (e.g., `pdo_pgsql`, `mbstring`, `tokenizer`, `xml`, `curl`, `zip`, `intl`).\n    *   **Application Code:** The PHP application code for Sector Wars 2102 will be mounted into this container.\n    *   **Composer:** Dependency management for PHP will be handled by Composer. The `Dockerfile` will include steps to install or copy Composer and install project dependencies.\n    *   **Working Directory:** Set to the application root (e.g., `/var/www/html`).\n\n2.  **Web Server Service (`web` or `nginx`):**\n    *   **Base Image:** Official Nginx image (e.g., `nginx:latest` or a specific stable version).\n    *   **Configuration:** Custom Nginx configuration to serve the PHP application (via PHP-FPM) and static assets.\n    *   **Ports:** Will expose port 80 (and/or 443 for HTTPS later) to the host machine.\n    *   **Dependencies:** Depends on the `app` service to process PHP files.\n\n3.  **PostgreSQL Database Service (`db`):**\n    *   **Base Image:** Official PostgreSQL image (e.g., `postgres:15` or `postgres:16`).\n    *   **Environment Variables:** Used to set the PostgreSQL user, password, and default database name.\n    *   **Data Persistence:** A Docker volume will be used to persist database data across container restarts (e.g., `pgdata`).\n    *   **Ports:** May expose the PostgreSQL port (5432) to the host for direct database access during development, but this is not strictly necessary if all database interaction happens through the `app` service.\n\n## `Dockerfile` (Conceptual for PHP `app` service):\n\n```dockerfile\n# Choose a PHP-FPM base image\nFROM php:8.3-fpm\n\n# Set working directory\nWORKDIR /var/www/html\n\n# Install system dependencies (e.g., for PHP extensions)\nRUN apt-get update && apt-get install -y \\\n    git \\\n    curl \\\n    libpng-dev \\\n    libjpeg62-turbo-dev \\\n    libfreetype6-dev \\\n    libzip-dev \\\n    libpq-dev \\\ # For PostgreSQL\n    # ... other dependencies ...\n    && apt-get clean \\\n    && rm -rf /var/lib/apt/lists/*\n\n# Install PHP extensions\nRUN docker-php-ext-configure gd --with-freetype --with-jpeg \\\n    && docker-php-ext-install gd pdo pdo_pgsql zip opcache intl\n\n# Install Composer (globally)\nCOPY --from=composer:latest /usr/bin/composer /usr/bin/composer\n\n# Copy application files (or mount via docker-compose)\n# COPY . .\n\n# Install Composer dependencies\n# RUN composer install --optimize-autoloader --no-dev\n\n# Expose port for PHP-FPM (if not already exposed by base image)\n# EXPOSE 9000\n\n# Command to run PHP-FPM (often handled by the base image)\n# CMD [\"php-fpm\"]\n```\n*(Note: The `COPY . .` and `composer install` steps are often handled by mounting the application code via `docker-compose.yml` and running composer commands inside the running container or as part of an entrypoint script for more flexibility during development.)*\n\n## `docker-compose.yml` (Conceptual):\n\n```yaml\nversion: '3.8'\n\nservices:\n  app:\n    build:\n      context: . # Path to the directory containing the Dockerfile for the app\n      dockerfile: Dockerfile # Or specify a different name/path\n    container_name: sectorwars_app\n    restart: unless-stopped\n    volumes:\n      - ./:/var/www/html # Mounts the project directory into the container\n    # environment:\n      # - APP_ENV=development\n      # - DB_CONNECTION=pgsql\n      # - DB_HOST=db\n      # - DB_PORT=5432\n      # - DB_DATABASE=sectorwars_db\n      # - DB_USERNAME=sectorwars_user\n      # - DB_PASSWORD=secret\n    depends_on:\n      - db\n    networks:\n      - sectorwars_network\n\n  web:\n    image: nginx:latest\n    container_name: sectorwars_web\n    restart: unless-stopped\n    ports:\n      - \"8080:80\" # Host port 8080 mapped to container port 80\n    volumes:\n      - ./:/var/www/html # For static assets if served directly by Nginx\n      - ./docker/nginx/default.conf:/etc/nginx/conf.d/default.conf # Mount Nginx config\n    depends_on:\n      - app\n    networks:\n      - sectorwars_network\n\n  db:\n    image: postgres:16-alpine\n    container_name: sectorwars_db\n    restart: unless-stopped\n    environment:\n      POSTGRES_DB: sectorwars_db\n      POSTGRES_USER: sectorwars_user\n      POSTGRES_PASSWORD: secret # Use environment variables or secrets for production\n    volumes:\n      - pgdata:/var/lib/postgresql/data # Persist data\n    # ports:\n      # - \"5432:5432\" # Optional: expose port to host for direct DB access\n    networks:\n      - sectorwars_network\n\nvolumes:\n  pgdata:\n    driver: local\n\nnetworks:\n  sectorwars_network:\n    driver: bridge\n```\n\n## Nginx Configuration (`docker/nginx/default.conf` - Conceptual):\n\n```nginx\nserver {\n    listen 80;\n    server_name localhost; # Or your development domain\n    root /var/www/html/public; # Assuming a public directory for your PHP framework\n\n    index index.php index.html index.htm;\n\n    location / {\n        try_files $uri $uri/ /index.php?$query_string;\n    }\n\n    location ~ \\.php$ {\n        try_files $uri =404;\n        fastcgi_split_path_info ^(.+\\.php)(/.+)$;\n        fastcgi_pass app:9000; # 'app' is the service name of the PHP-FPM container\n        fastcgi_index index.php;\n        include fastcgi_params;\n        fastcgi_param SCRIPT_FILENAME $document_root$fastcgi_script_name;\n        fastcgi_param PATH_INFO $fastcgi_path_info;\n    }\n\n    location ~ /\\.ht {\n        deny all;\n    }\n}\n```\n\n## Next Steps (for DevOps in Iteration 2):\n\n1.  Create the actual `Dockerfile` for the PHP application.\n2.  Create the actual `docker-compose.yml` file.\n3.  Create the Nginx configuration file (`default.conf`).\n4.  Test the Docker setup to ensure all services build and run correctly.\n5.  Document commands for building, starting, stopping, and accessing logs of the Docker environment (e.g., `docker-compose up -d --build`, `docker-compose down`, `docker-compose logs -f app`).\n6.  Consider adding tools like Adminer or pgAdmin as an optional service in `docker-compose.yml` for easier database management during development.\n
